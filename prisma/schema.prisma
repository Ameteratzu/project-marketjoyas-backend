// This is your Prisma schema file, 
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

//////////////////////////////
///////////ENUMS//////////////
//////////////////////////////

enum Rol {
  ADMIN
  CLIENTE
  DEMOVENDEDOR
  VENDEDOR
  TRABAJADOR
}



enum EstadoCotizacion {
  PENDIENTE
  APROBADA
  DENEGADA
}

enum tipoMovimiento {
  ENTRADA
  SALIDA
}

enum ProveedorOAuth {
  GOOGLE
  FACEBOOK
}



//////////////////////////////
///////////CuentaOAuth/////////// check
//////////////////////////////

model CuentaOAuth {
  id        Int            @id @default(autoincrement())
  proveedor ProveedorOAuth
  oauthId   String // Este es el ID que te da Google, Facebook, etc. para identificar al usuario en su sistema.
  // No es unico porque dos proveedores distintos podrian dar el mismo ID por coincidencia.
  email     String //este email viene del proveedor y se usara para buscar coincidencias en la tabla usuario
  usuario   Usuario        @relation(fields: [usuarioId], references: [id])
  usuarioId Int

  @@unique([proveedor, oauthId]) // evita que se repita el mismo oauth id con el mismo proveedor
}

//////////////////////////////
///////////USUARIO/////////// check
//////////////////////////////

enum TipoDocumentoIdentidad {
  DNI  // 1
  RUC  // 6
  CE   // 4 - Carnet extranjería (opcional si vendes a extranjeros)
  OTRO // 0
}

model Usuario {
  id              Int      @id @default(autoincrement())
  nombre_completo String //incluye apellidos
  username        String?  @unique // opcional para CLIENTE, requerido para VENDEDOR
  email           String   @unique
  tipoDocumento   TipoDocumentoIdentidad? @default(DNI) // Nuevo
  dni             String?   @unique //LO HE DEJADO COMO DNI PARA QUE NO SE ROMPA NADA PERO PUEDE SER RUC10, O CE
  razonSocial     String?  // Nuevo: solo si el cliente tiene RUC
  telefono        String
  direccion       String?
  contraseña      String
  rol             Rol      @default(CLIENTE)
  creadoEn        DateTime @default(now())
  
  fotoPerfilUrl      String? 
  fotoPerfilPublicId String?

  tiendaPropia Tienda? @relation("DueñoTienda") // solo si es VENDEDOR
  trabajaEn    Tienda? @relation("TrabajadoresTienda", fields: [tiendaId], references: [id]) // si es TRABAJADOR
  tiendaId     Int?

  pedidos              Pedido[] // 1:N → un usuario puede hacer muchos pedidos
  favoritos            Favorito[] // 1:N → un usuario puede marcar muchos productos como favoritos
  carrito              CarritoProducto[] // 1:N → un usuario puede tener muchos productos en el carrito
  comparaciones        Comparacion[] // 1:N → un usuario puede comparar varios productos
  calificaciones       Calificacion[] // 1:N → un usuario puede calificar muchos productos
  cotizaciones         SolicitudCotizacion[] // 1:N → un usuario puede solicitar varias cotizaciones
  movimientoInventario MovimientoInventario[]
  cuentasOAuth         CuentaOAuth[] //1:N

  recuperacionContraseña RecuperacionContraseña?  @relation("UsuarioRecuperacion")  // 1:1 relación opcional

  documento         Documento []


}
model RecuperacionContraseña {
  id           Int      @id @default(autoincrement())
  usuario    Usuario  @relation("UsuarioRecuperacion", fields: [usuarioId], references: [id])
  usuarioId    Int  @unique
  token        String   @unique
  creadoEn     DateTime @default(now())
  expiracion   DateTime
  usado        Boolean  @default(false)
}

//////////////////////////////
///////////TIENDA///////////  check
//////////////////////////////

enum EstadoPedido {
  PENDIENTE
  EMPAQUETADO
  DESPACHO
  ENVIO
  ENTREGA
}

model Tienda {
  id           Int     @id @default(autoincrement())
  usuario      Usuario @relation("DueñoTienda", fields: [usuarioId], references: [id])
  usuarioId    Int     @unique
  nombre       String? //razon social
  direccion    String? //direccion fiscal
  telefono     String?  //numero de wsp
  pais         String?
  ciudad       String?
  provincia    String?
  departamento String?
  distrito     String?
  codigoPostal String?
  logo         String? //url es una imgaen 
  logoPublicId String? //id que da cloudinary
  ruc          String?
  emailTienda  String? //email para la tienda

  productos    Producto[]
  cupones      Cupon[]
  propuestas   PropuestaCotizacion[]
  trabajadores Usuario[]             @relation("TrabajadoresTienda") // varios usuarios con rol TRABAJADOR
  suscripcion  Suscripcion?
  pedidos      Pedido[]  // relación inversa
  documento    Documento []
  certificado  CertificadoDigital? //1:1
  serieCorrelativo SerieCorrelativo[]
}

//////////////////////////////
///////////SUSCRIPCION////////// check
//////////////////////////////

model Suscripcion {
  id       Int      @id @default(autoincrement())
  tienda   Tienda   @relation(fields: [tiendaId], references: [id])
  tiendaId Int      @unique
  tipo     String // mensual o anual
  inicio   DateTime @default(now())
  fin      DateTime
  activa   Boolean  @default(true)
}

//////////////////////////////
///////////CATEGORIA//////////
//////////////////////////////

model Categoria {
  id        Int        @id @default(autoincrement())
  nombre    String     @unique
  productos Producto[] // 1:N → una categoría puede tener muchos productos
}

//////////////////////////////
///////////PRODUCTO///////////
//////////////////////////////

model Producto {
  id          Int      @id @default(autoincrement())
  nombre      String
  descripcion String?
  precio      Decimal  @db.Decimal(10, 2)
  enStock     Int      @default(0)
  creadoEn    DateTime @default(now())
  habilitado  Boolean  @default(true) // lo he añadido para soft delete, para mantener trazabilidad.

  imagen   String?
  tienda   Tienda  @relation(fields: [tiendaId], references: [id])
  tiendaId Int

  categoria   Categoria? @relation(fields: [categoriaId], references: [id]) // N:1 opcional → un producto puede pertenecer a una categoría
  categoriaId Int?

  gemaId Int?
  gema   Gema? @relation(fields: [gemaId], references: [id])

  materialId Int?
  material   Material? @relation(fields: [materialId], references: [id])

  estiloId Int?
  estilo   Estilo? @relation(fields: [estiloId], references: [id])

  ocasionId Int?
  ocasion   Ocasion? @relation(fields: [ocasionId], references: [id])

  cupones        Cupon[] // 1:N → un producto puede tener varios cupones asignados
  pedidos        PedidoDetalle[] // N:M → relación con Pedido a través de PedidoProducto
  calificaciones Calificacion[] // 1:N → un producto puede recibir muchas calificaciones
  favoritos      Favorito[] // N:M → relación con Usuario
  carrito        CarritoProducto[] // N:M → relación con Usuario
  comparaciones  Comparacion[] // N:M → relación con Usuario

  ofertaGlobal   OfertaGlobal? @relation(fields: [ofertaGlobalId], references: [id]) // N:1 → un producto puede tener como máximo UNA oferta global activa
  ofertaGlobalId Int?

  movimientoInventario MovimientoInventario[]

  imagenes ImagenProducto[] // Relación 1:N
}

model Ocasion {
  id        Int        @id @default(autoincrement())
  nombre    String     @unique
  productos Producto[]
}

model Estilo {
  id        Int        @id @default(autoincrement())
  nombre    String     @unique
  productos Producto[]
}

model Gema {
  id        Int        @id @default(autoincrement())
  nombre    String     @unique
  productos Producto[]
   certificados CertificadoJoya[]  

}

model Material {
  id        Int        @id @default(autoincrement())
  nombre    String     @unique
  productos Producto[]
  certificados CertificadoJoya[]  

}

//////////////////////////////
///////////Imagen producto/////////// Para que tenga varias imagenes
//////////////////////////////

model ImagenProducto {
  id         Int      @id @default(autoincrement())
  url        String
  public_id  String? // para imagenes cloudinary
  producto   Producto @relation(fields: [productoId], references: [id])
  productoId Int
}

//////////////////////////////
///////////MOVIMIENTO INVENTARIO///////////
//////////////////////////////

//AGREGUE ESTA TABLA PARA TENER REGISTRO DE LOS MOVIMIENTOS DE INVENTARIO
//CUANDO UN CLIENTE COMPRE O UN VENDEDOR/TRABAJADOR ELIMINE/AÑADA PRODUCTOS QUEDARA REGISTRADO AQUI

model MovimientoInventario {
  id       Int            @id @default(autoincrement())
  tipo     tipoMovimiento @default(ENTRADA) // "ENTRADA" o "SALIDA"
  cantidad Int
  fecha    DateTime       @default(now())

  producto   Producto @relation(fields: [productoId], references: [id])
  productoId Int

  usuario   Usuario @relation(fields: [usuarioId], references: [id])
  usuarioId Int
}

//////////////////////////////
///////////PEDIDO//////////// check
//////////////////////////////

model Pedido {
  id                Int             @id @default(autoincrement())
  usuario           Usuario         @relation(fields: [usuarioId], references: [id]) // N:1 → cada pedido pertenece a un usuario
  usuarioId         Int
  tienda            Tienda          @relation(fields: [tiendaId], references: [id]) // NUEVO
  tiendaId          Int             // NUEVO
  fecha             DateTime        @default(now())
  estado            EstadoPedido    @default(PENDIENTE)
  codigoSeguimiento String?          @unique
  productos         PedidoDetalle[] // N:M → relación con Producto
  pago              Pago? //1:1
  documento         Documento? 
}

////////////////////////////////
///////////PEDIDO DETALLE/////// check
////////////////////////////////

model PedidoDetalle {
  id         Int      @id @default(autoincrement())
  pedido     Pedido   @relation(fields: [pedidoId], references: [id]) // N:1 → pertenece a un pedido
  pedidoId   Int
  producto   Producto @relation(fields: [productoId], references: [id]) // N:1 → pertenece a un producto
  productoId Int
  cantidad   Int
}

////////////////////////////////
/////////// CERTIFICADO JOYAS/////// check
////////////////////////////////


model CertificadoJoya {
  id              Int      @id @default(autoincrement())

  tiendaNombre    String
  tiendaDireccion String

  clienteNombre String
  clienteDnioRUC            String

  productoNombre  String

  gema          Gema     @relation(fields: [gemaId], references: [id])
  gemaId        Int

  material      Material @relation(fields: [materialId], references: [id])
  materialId    Int
  pais        String?
  descripcion   String?
  precio        Decimal  @db.Decimal(10, 2)
  imagenUrl     String?  // URL de la imagen del certificado (subida a Cloudinary)

  fechaEmision  DateTime @default(now())
}









////////////////////////////////
/////////// EMISION ELECTRONICA SUNAT/////// AUN POR CONFIRMAR
////////////////////////////////


////////////////////////////////
///////////  DOCUMENTO/////// AUN POR CONFIRMAR
////////////////////////////////

enum Moneda {
  PEN
  USD
  EUR
}
model Documento {
  id           Int      @id @default(autoincrement())
  tipo         String   // "BOLETA", "FACTURA"
  numero       String   @unique // número correlativo (serie + número)
  serie        String
  fechaEmision DateTime @default(now())

  

  moneda       Moneda   @default(PEN)
  tipoCambio   Decimal? @db.Decimal(10, 4) // si moneda ≠ PEN
  
  subtotal     Decimal  @db.Decimal(10, 2)
  opGravado    Decimal  @db.Decimal(10, 2)
  igv          Decimal  @db.Decimal(10, 2)
  total        Decimal  @db.Decimal(10, 2)
  
  formaPago    String
  condVenta    String

  // Relaciones
  pedido       Pedido   @relation(fields: [pedidoId], references: [id])
  pedidoId     Int      @unique

  usuario      Usuario  @relation(fields: [usuarioId], references: [id])
  usuarioId    Int

  tienda       Tienda   @relation(fields: [tiendaId], references: [id])
  tiendaId     Int
  logEnvio     LogEnvioSunat[]

  // Nuevos campos para emisión electrónica SUNAT
  estadoSunat     String?   // "PENDIENTE", "ACEPTADO", "RECHAZADO", "OBSERVADO"
  codigoSunat     String?   // Código de respuesta SUNAT (CDR)
  descripcionSunat String?  // Mensaje o descripción de SUNAT (CDR)
  hashDocumento   String?   // Hash o firma digital para integridad

  xmlRuta         String?   // Ruta o URL al XML firmado
  zipRuta         String?   // Ruta o URL al ZIP enviado a SUNAT
  cdrRuta         String?   // Ruta o URL al CDR recibido (comprobante SUNAT)
  pdfRuta         String?   // Ruta o URL al PDF generado para el cliente

  modoEmision     String?   // "PRUEBAS" o "PRODUCCIÓN"
  fechaEnvio      DateTime? // Fecha y hora cuando se envió el comprobante a SUNAT
}


////////////////////////////////
///////////  CERTIFICADO/////// AUN POR CONFIRMAR
////////////////////////////////
model CertificadoDigital {
  id            Int      @id @default(autoincrement())
  tienda        Tienda   @relation(fields: [tiendaId], references: [id])
  tiendaId      Int      @unique

  certificado   Bytes    // Guardamos el archivo .pfx en binario (encriptado)
  contraseña    String   // Contraseña para el certificado (guardarla cifrada en backend)

  fechaInicio   DateTime
  fechaExpiracion DateTime

  estado        String   // "ACTIVO", "EXPIRADO", "REVOCADO"

  creadoEn      DateTime @default(now())
  actualizadoEn DateTime @updatedAt
}


////////////////////////////////
///////////  LOG ENVIO/////// AUN POR CONFIRMAR
////////////////////////////////

model LogEnvioSunat {
  id            Int      @id @default(autoincrement())
  documento     Documento @relation(fields: [documentoId], references: [id])
  documentoId   Int

  fechaEnvio    DateTime @default(now())
  estadoEnvio   String   // "ENVIADO", "ERROR", "REINTENTO", etc.
  mensaje       String?  // Mensaje o error recibido
  intento       Int      @default(1) // número de intento

  respuestaSunat Json?   // Datos crudos recibidos de SUNAT (opcional)
}


////////////////////////////////
///////////  SERIE CORRELATIVO/////// AUN POR CONFIRMAR
////////////////////////////////

model SerieCorrelativo {
  id           Int      @id @default(autoincrement())
  tienda       Tienda   @relation(fields: [tiendaId], references: [id])
  tiendaId     Int

  tipoDocumento String  // "FACTURA", "BOLETA", etc.
  serie         String  // "F001", "B001", etc.
  ultimoNumero  Int     // último número usado (ej: 1234)

  activo        Boolean  @default(true) // si quieres desactivar alguna serie
  creadoEn      DateTime @default(now())
  actualizadoEn DateTime @updatedAt

  @@unique([tiendaId, tipoDocumento, serie]) // cada tienda tiene su serie única por tipo
}





////////////////////////////////
///////////PAGO TRANSACCIONES/////// check
////////////////////////////////

enum ProveedorPago {
  MERCADOPAGO
  IZIPAY
  OTRO
}

model Pago {
  id               Int           @id @default(autoincrement())
  pedido           Pedido        @relation(fields: [pedidoId], references: [id])
  pedidoId         Int           @unique
  proveedorPago    ProveedorPago
  transaccionId    String        @unique // ID de la transacción en el proveedor (Mercado Pago, Izipay, etc.)
  estado           String        // approved, pending, rejected, etc.
  metodoPago       String?       // credit_card, debit_card, ticket, etc.
  monto            Decimal       @db.Decimal(10, 2)
  fechaPago        DateTime
  datosAdicionales  Json?        // para info extra específica de cada proveedor
}

//TODOS LOS DATOS SON PROPORCIONADOS POR MERCADO PAGO MENOS ID Y PEDIDO ID 

////////////////////////////////
///////////CALIFICACION///////// check
////////////////////////////////

model Calificacion {
  id         Int      @id @default(autoincrement())
  usuario    Usuario  @relation(fields: [usuarioId], references: [id]) // N:1 → una calificación pertenece a un usuario
  usuarioId  Int
  producto   Producto @relation(fields: [productoId], references: [id]) // N:1 → una calificación pertenece a un producto
  productoId Int
  estrellas  Int
  comentario String?
  fecha      DateTime @default(now())
}

////////////////////////////////
///////////CUPON/////////////// check
////////////////////////////////

model Cupon {
  id          Int       @id @default(autoincrement())
  codigo      String    @unique
  descuento   Float
  tienda      Tienda    @relation(fields: [tiendaId], references: [id]) // N:1 → un cupón pertenece a una tienda
  tiendaId    Int
  producto    Producto? @relation(fields: [productoId], references: [id]) // N:1 opcional → un cupón puede aplicarse a un producto específico
  productoId  Int?
  validoHasta DateTime
  usado       Boolean   @default(false) // para ver si ya ha sido usado
}

////////////////////////////////
///////////SolicitudCOTIZACION/////////// check
////////////////////////////////

model SolicitudCotizacion {
  id          Int                   @id @default(autoincrement())
  usuario     Usuario?              @relation(fields: [usuarioId], references: [id]) // N:1 → una cotización pertenece a un usuario
  usuarioId   Int?
  imagenUrl   String?
  descripcion String?
  estado      EstadoCotizacion      @default(PENDIENTE)
  propuestas  PropuestaCotizacion[] // 1:N → una cotización puede recibir muchas propuestas de vendedores

//para usuarios no autenticados
  contactoEmail    String?
  contactoTelefono String?
  contactoNombre   String? // nuevo campo

}

////////////////////////////////
//////PROPUESTACOTIZACION/////// check pero es opcional ya que los mensajes se manejaran por wsp
//////////////////////////////

model PropuestaCotizacion {
  id           Int                 @id @default(autoincrement())
  cotizacion   SolicitudCotizacion @relation(fields: [cotizacionId], references: [id]) // N:1 → pertenece a una cotización
  cotizacionId Int
  tienda       Tienda              @relation(fields: [tiendaId], references: [id]) // N:1 → un cupón pertenece a una tienda
  tiendaId     Int
  precio       Float
  descripcion  String?
  fecha        DateTime            @default(now())
}

////////////////////////////////
///////////FAVORITO//////////// check 
////////////////////////////////

model Favorito {
  id         Int      @id @default(autoincrement())
  usuario    Usuario  @relation(fields: [usuarioId], references: [id]) // N:1 → un favorito pertenece a un usuario
  usuarioId  Int
  producto   Producto @relation(fields: [productoId], references: [id]) // N:1 → un favorito pertenece a un producto
  productoId Int

  @@unique([usuarioId, productoId]) // un usuario no puede tener el mismo favorito dos veces, no duplicados
}

//////////////////////////////
//////CARRITOPRODUCTO///////////  check
////////////////////////////////

model CarritoProducto {
  id         Int      @id @default(autoincrement())
  usuario    Usuario  @relation(fields: [usuarioId], references: [id]) // N:1 → un ítem de carrito pertenece a un usuario
  usuarioId  Int
  producto   Producto @relation(fields: [productoId], references: [id]) // N:1 → un ítem de carrito pertenece a un producto
  productoId Int
  cantidad   Int

  @@unique([usuarioId, productoId]) //Evito duplicados igual que en favoritos
}

////////////////////////////////
//////////COMPARACION////// check 
////////////////////////////////

model Comparacion {
  id         Int      @id @default(autoincrement())
  usuario    Usuario  @relation(fields: [usuarioId], references: [id]) // N:1 → una comparación pertenece a un usuario
  usuarioId  Int
  producto   Producto @relation(fields: [productoId], references: [id]) // N:1 → una comparación pertenece a un producto
  productoId Int

  @@unique([usuarioId, productoId]) //Evito duplicados igual que en favoritos y carrito
}

////////////////////////////////
///////////OFERTAGLOBAL////// check
///////////////////////////////

model OfertaGlobal {
  id          Int      @id @default(autoincrement())
  titulo      String
  descripcion String?
  descuento   Float
  validoHasta DateTime
  activo      Boolean  @default(true) //para no estar eliminando ofertas globales

  productos Producto[] // 1:N → una oferta global puede aplicarse a varios productos
}

////////////////////////////// 
/////// RESUMEN RELACIONES ///
//////////////////////////////

// Usuario - Tienda (dueño) → 1:1 opcional
// Usuario - Tienda (trabajador) → N:1 (un trabajador pertenece a una tienda, una tienda tiene muchos trabajadores)

// Usuario - Pedido → 1:N
// Usuario - Calificacion → 1:N
// Usuario - Favorito → 1:N
// Usuario - CarritoProducto → 1:N
// Usuario - Comparacion → 1:N
// Usuario - Cotizacion → 1:N

// Tienda - Producto → 1:N
// Tienda - Cupon → 1:N
// Tienda - PropuestaCotizacion → 1:N

// Categoria - Producto → 1:N

// Producto - Pedido → N:M (a través de PedidoProducto)
// Producto - Calificacion → 1:N
// Producto - Favorito → N:M
// Producto - CarritoProducto → N:M
// Producto - Comparacion → N:M
// Producto - Cupon → 1:N (producto puede tener varios cupones)
// Producto - OfertaGlobal → N:1 (un producto solo puede estar en UNA oferta global a la vez)

// OfertaGlobal - Producto → 1:N (una oferta global aplica a muchos productos)

// Cotizacion - PropuestaCotizacion → 1:N
