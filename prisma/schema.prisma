
// This is your Prisma schema file, 
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

//////////////////////////////
///////////ENUMS//////////////
//////////////////////////////

enum Rol {
  ADMIN
  CLIENTE
  VENDEDOR
  TRABAJADOR
}
  
enum EstadoPedido {
  EMPAQUETADO
  DESPACHO
  ENVIO
  ENTREGA
}

enum EstadoCotizacion {
  PENDIENTE
  APROBADA
  DENEGADA
}

enum Material {
  PLATA
  ORO
  ORO_18K
}

enum Gema {
  ZIRCONIA
  DIAMANTE
  ESMERALDA
}

enum Estilo {
  NIÑOS
  NIÑAS
  HOMBRES
  MUJERES
}

enum Ocasion {
  GRADUACION
  ANIVERSARIO
  REGALO
  BODA
}

enum tipoMovimiento {
  ENTRADA
  SALIDA
}


enum ProveedorOAuth {
  GOOGLE
  FACEBOOK
}


//////////////////////////////
///////////CuentaOAuth/////////// check
//////////////////////////////


model CuentaOAuth {

  id Int @id @default(autoincrement())
  proveedor ProveedorOAuth
  oauthId String       // Este es el ID que te da Google, Facebook, etc. para identificar al usuario en su sistema.
                       // No es unico porque dos proveedores distintos podrian dar el mismo ID por coincidencia.
  email String         //este email viene del proveedor y se usara para buscar coincidencias en la tabla usuario
  usuario Usuario  @relation(fields: [usuarioId], references: [id])
  usuarioId    Int 

  @@unique([proveedor, oauthId]) // evita que se repita el mismo oauth id con el mismo proveedor


}


//////////////////////////////
///////////USUARIO/////////// check
//////////////////////////////

model Usuario {
  id        Int      @id @default(autoincrement())
  nombre_completo    String //incluye apellidos
  username    String?   @unique // opcional para CLIENTE, requerido para VENDEDOR
  email     String   @unique
  dni         String    @unique
  telefono  String
  direccion String?
  contraseña  String
  rol       Rol      @default(CLIENTE)
  creadoEn  DateTime @default(now())

  tiendaPropia Tienda?   @relation("DueñoTienda")     // solo si es VENDEDOR
  trabajaEn    Tienda?   @relation("TrabajadoresTienda", fields: [tiendaId], references: [id]) // si es TRABAJADOR
  tiendaId      Int?

  pedidos        Pedido[]           // 1:N → un usuario puede hacer muchos pedidos
  favoritos      Favorito[]         // 1:N → un usuario puede marcar muchos productos como favoritos
  carrito        CarritoProducto[]  // 1:N → un usuario puede tener muchos productos en el carrito
  comparaciones  Comparacion[]      // 1:N → un usuario puede comparar varios productos
  calificaciones Calificacion[]     // 1:N → un usuario puede calificar muchos productos
  cotizaciones   SolicitudCotizacion[]       // 1:N → un usuario puede solicitar varias cotizaciones
  movimientoInventario MovimientoInventario[] 
  cuentasOAuth  CuentaOAuth[] //1:N
}

//////////////////////////////
///////////TIENDA///////////  check
//////////////////////////////

model Tienda {
  id            Int       @id @default(autoincrement())
  usuario        Usuario   @relation("DueñoTienda", fields: [usuarioId], references: [id])
  usuarioId       Int       @unique
  nombre        String
  direccion     String
  telefono      String
  pais          String
  ciudad        String
  provincia     String
  codigoPostal  String

  productos     Producto[]
  cupones       Cupon[]
  propuestas    PropuestaCotizacion[]
  trabajadores  Usuario[] @relation("TrabajadoresTienda") // varios usuarios con rol TRABAJADOR
  suscripcion   Suscripcion?
}

//////////////////////////////
///////////SUSCRIPCION////////// check
//////////////////////////////

model Suscripcion {
  id         Int      @id @default(autoincrement())
  tienda     Tienda   @relation(fields: [tiendaId], references: [id])
  tiendaId   Int      @unique
  tipo       String   // mensual o anual
  inicio     DateTime @default(now())
  fin        DateTime
  activa     Boolean  @default(true)
}


//////////////////////////////
///////////CATEGORIA//////////
//////////////////////////////

model Categoria {
  id        Int       @id @default(autoincrement())
  nombre    String    @unique
  productos Producto[] // 1:N → una categoría puede tener muchos productos
}

//////////////////////////////
///////////PRODUCTO///////////
//////////////////////////////

model Producto {
  id          Int       @id @default(autoincrement())
  nombre      String
  descripcion String?
  precio      Decimal   @db.Decimal(10,2)
  enStock     Int       @default(0)
  creadoEn    DateTime  @default(now())
  habilitado Boolean @default(true) // lo he añadido para soft delete, para mantener trazabilidad.


  imagen       String?   
  tienda       Tienda    @relation(fields: [tiendaId], references: [id])
  tiendaId     Int

  material    Material?
  gema        Gema?
  estilo      Estilo?
  ocasion     Ocasion?

  categoria   Categoria? @relation(fields: [categoriaId], references: [id]) // N:1 opcional → un producto puede pertenecer a una categoría
  categoriaId Int?

  cupones        Cupon[]            // 1:N → un producto puede tener varios cupones asignados
  pedidos        PedidoDetalle[]   // N:M → relación con Pedido a través de PedidoProducto
  calificaciones Calificacion[]     // 1:N → un producto puede recibir muchas calificaciones
  favoritos      Favorito[]         // N:M → relación con Usuario
  carrito        CarritoProducto[]  // N:M → relación con Usuario
  comparaciones  Comparacion[]      // N:M → relación con Usuario

  ofertaGlobal   OfertaGlobal? @relation(fields: [ofertaGlobalId], references: [id]) // N:1 → un producto puede tener como máximo UNA oferta global activa
  ofertaGlobalId Int?

  movimientoInventario MovimientoInventario[]

  imagenes    ImagenProducto[] // Relación 1:N
}

//////////////////////////////
///////////Imagen producto/////////// Para que tenga varias imagenes
//////////////////////////////

model ImagenProducto {
  id         Int      @id @default(autoincrement())
  url        String   
  producto   Producto @relation(fields: [productoId], references: [id])
  productoId Int
}


//////////////////////////////
///////////MOVIMIENTO INVENTARIO///////////
//////////////////////////////

//AGREGUE ESTA TABLA PARA TENER REGISTRO DE LOS MOVIMIENTOS DE INVENTARIO
//CUANDO UN CLIENTE COMPRE O UN VENDEDOR/TRABAJADOR ELIMINE/AÑADA PRODUCTOS QUEDARA REGISTRADO AQUI

model MovimientoInventario {
  id         Int      @id @default(autoincrement())
  tipo       tipoMovimiento @default(ENTRADA)   // "ENTRADA" o "SALIDA"
  cantidad   Int
  fecha      DateTime @default(now())

  producto   Producto @relation(fields: [productoId], references: [id])
  productoId Int

  usuario    Usuario  @relation(fields: [usuarioId], references: [id])
  usuarioId  Int
}

//////////////////////////////
///////////PEDIDO//////////// check
//////////////////////////////

model Pedido {
  id               Int       @id @default(autoincrement())
  usuario          Usuario   @relation(fields: [usuarioId], references: [id]) // N:1 → cada pedido pertenece a un usuario
  usuarioId        Int
  fecha            DateTime  @default(now())
  estado           EstadoPedido @default(EMPAQUETADO)
  codigoSeguimiento String   @unique
  productos        PedidoDetalle[] // N:M → relación con Producto
  pago             Pago?  //1:1
}

////////////////////////////////
///////////PEDIDO DETALLE/////// check
////////////////////////////////

model PedidoDetalle {
  id          Int      @id @default(autoincrement())
  pedido      Pedido   @relation(fields: [pedidoId], references: [id])  // N:1 → pertenece a un pedido
  pedidoId    Int
  producto    Producto @relation(fields: [productoId], references: [id]) // N:1 → pertenece a un producto
  productoId  Int
  cantidad    Int
}

////////////////////////////////
///////////PAGO TRANSACCIONES/////// check
////////////////////////////////

model Pago {
  id                 Int       @id @default(autoincrement())
  pedido             Pedido    @relation(fields: [pedidoId], references: [id])
  pedidoId           Int       @unique
  mercadoPagoId      String    @unique  // ID de la transacción en Mercado Pago
  estado             String    // approved, Pending, rejected, etc.
  metodoPago         String?   // credit_card, debit_card, ticket, etc.
  monto              Decimal   @db.Decimal(10,2)
  fechaPago          DateTime
  datosAdicionales   Json?     // para guardar info extra 
} //TODOS LOS DATOS SON PROPORCIONADOS POR MERCADO PAGO MENOS ID Y PEDIDO ID 




////////////////////////////////
///////////CALIFICACION///////// check
////////////////////////////////

model Calificacion {
  id          Int      @id @default(autoincrement())
  usuario     Usuario  @relation(fields: [usuarioId], references: [id]) // N:1 → una calificación pertenece a un usuario
  usuarioId   Int
  producto    Producto @relation(fields: [productoId], references: [id]) // N:1 → una calificación pertenece a un producto
  productoId  Int
  estrellas   Int      
  comentario  String?
  fecha       DateTime @default(now())
}

////////////////////////////////
///////////CUPON/////////////// check
////////////////////////////////

model Cupon {
  id           Int      @id @default(autoincrement())
  codigo       String   @unique
  descuento    Float
  tienda       Tienda    @relation(fields: [tiendaId], references: [id]) // N:1 → un cupón pertenece a una tienda
  tiendaId     Int
  producto     Producto? @relation(fields: [productoId], references: [id]) // N:1 opcional → un cupón puede aplicarse a un producto específico
  productoId   Int?
  validoHasta  DateTime
  usado       Boolean  @default(false) // para ver si ya ha sido usado
}

////////////////////////////////
///////////SolicitudCOTIZACION/////////// check
////////////////////////////////

model SolicitudCotizacion {
  id           Int      @id @default(autoincrement())
  usuario      Usuario  @relation(fields: [usuarioId], references: [id]) // N:1 → una cotización pertenece a un usuario
  usuarioId    Int
  imagenUrl    String
  estado       EstadoCotizacion @default(PENDIENTE)
  propuestas   PropuestaCotizacion[] // 1:N → una cotización puede recibir muchas propuestas de vendedores
}

////////////////////////////////
//////PROPUESTACOTIZACION/////// check pero es opcional ya que los mensajes se manejaran por wsp
//////////////////////////////

model PropuestaCotizacion {
  id           Int       @id @default(autoincrement())
  cotizacion   SolicitudCotizacion @relation(fields: [cotizacionId], references: [id]) // N:1 → pertenece a una cotización
  cotizacionId Int
  tienda       Tienda    @relation(fields: [tiendaId], references: [id]) // N:1 → un cupón pertenece a una tienda
  tiendaId     Int
  precio       Float
  descripcion  String?
  fecha        DateTime @default(now())
}

////////////////////////////////
///////////FAVORITO//////////// check 
////////////////////////////////

model Favorito {
  id          Int      @id @default(autoincrement())
  usuario     Usuario  @relation(fields: [usuarioId], references: [id]) // N:1 → un favorito pertenece a un usuario
  usuarioId   Int
  producto    Producto @relation(fields: [productoId], references: [id]) // N:1 → un favorito pertenece a un producto
  productoId  Int
   @@unique([usuarioId, productoId]) // un usuario no puede tener el mismo favorito dos veces, no duplicados
}

//////////////////////////////
//////CARRITOPRODUCTO///////////  check
////////////////////////////////

model CarritoProducto {
  id          Int      @id @default(autoincrement())
  usuario     Usuario  @relation(fields: [usuarioId], references: [id]) // N:1 → un ítem de carrito pertenece a un usuario
  usuarioId   Int
  producto    Producto @relation(fields: [productoId], references: [id]) // N:1 → un ítem de carrito pertenece a un producto
  productoId  Int
  cantidad    Int
  @@unique([usuarioId, productoId]) //Evito duplicados igual que en favoritos
}

////////////////////////////////
//////////COMPARACION////// check 
////////////////////////////////

model Comparacion {
  id          Int      @id @default(autoincrement())
  usuario     Usuario  @relation(fields: [usuarioId], references: [id]) // N:1 → una comparación pertenece a un usuario
  usuarioId   Int
  producto    Producto @relation(fields: [productoId], references: [id]) // N:1 → una comparación pertenece a un producto
  productoId  Int

  @@unique([usuarioId, productoId]) //Evito duplicados igual que en favoritos y carrito

}

////////////////////////////////
///////////OFERTAGLOBAL////// check
///////////////////////////////

model OfertaGlobal {
  id          Int       @id @default(autoincrement())
  titulo      String
  descripcion String?
  descuento   Float
  validoHasta DateTime
  activo Boolean @default(true) //para no estar eliminando ofertas globales

  productos   Producto[] // 1:N → una oferta global puede aplicarse a varios productos
}


////////////////////////////// 
/////// RESUMEN RELACIONES ///
//////////////////////////////

// Usuario - Tienda (dueño) → 1:1 opcional
// Usuario - Tienda (trabajador) → N:1 (un trabajador pertenece a una tienda, una tienda tiene muchos trabajadores)

// Usuario - Pedido → 1:N
// Usuario - Calificacion → 1:N
// Usuario - Favorito → 1:N
// Usuario - CarritoProducto → 1:N
// Usuario - Comparacion → 1:N
// Usuario - Cotizacion → 1:N

// Tienda - Producto → 1:N
// Tienda - Cupon → 1:N
// Tienda - PropuestaCotizacion → 1:N

// Categoria - Producto → 1:N

// Producto - Pedido → N:M (a través de PedidoProducto)
// Producto - Calificacion → 1:N
// Producto - Favorito → N:M
// Producto - CarritoProducto → N:M
// Producto - Comparacion → N:M
// Producto - Cupon → 1:N (producto puede tener varios cupones)
// Producto - OfertaGlobal → N:1 (un producto solo puede estar en UNA oferta global a la vez)

// OfertaGlobal - Producto → 1:N (una oferta global aplica a muchos productos)

// Cotizacion - PropuestaCotizacion → 1:N

